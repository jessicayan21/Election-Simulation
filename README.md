# Election-Simulation
Project: Developed stochastic simulations and recursive algorithms to predict outcomes and number of possible ties in a USA presidential election 

# recursion.py explanation: 
The number of states is equal to the length of the "votes" list since each element in that list represents a state. The smallest case would be when there are no more states left, when length of the votes list is less than or equal to 0. This would be the base case, so this recursion function would start from here. In the base case, votes[states:] should be empty, meaning that if the sum of all the elements in it is 0, then return 1. Otherwise, return 0. The parameter for 'states' is thus 0 in the function call so that when the function calls itself later, it will increase by one until it is greater or equal to the length of the "votes" list which is 51. In this problem, there are two options using recursion: to include the number of votes that the last state has and find the number of ties with it or to find the number of ties without that state. The number of votes the last state has is denoted by "votes[states]". Now, we have divided the case of 51 states into two cases of just 50 states - one in which we are trying to find a subset with the sum of "tie" and the other in which we are trying to find a subset with the sum of the difference of the "tie" and the number of votes of the last state. I created a variable "tie_count" to account for the number of times that the sum is found for each case. Then, I added them together by updating "tie_count" with the number of subsets for the second case (this is the ultimate solution). Within each "recursion" function call, the number of "states" increases until it is greater than or equal to the length of the "votes" list. When it is, it will check if the total amount of ties is equal to 0. If it is not, "tie_count" will be stored a value of 0. This variable will then be updated with the value of the next function call in which the number of ties we are trying to find is without the last state's number of votes (second option). Thus, we have separated each case into two recursions. Each recursive function would continue to be separated into two cases, making the number of possibilities of the subset's sum equalling the tie to increase exponentially, hence causing the recursive method to take longer time in processing. Since the second recursive call takes in the number of votes without the last state that would add up to the number of votes needed for a tie, everytime this recursive call is called and the number of states is greater than or equal to the length of the 'votes' list, if the number of votes is equal to 0 (the 'tie' variable would be 0, meaning the sum is finally equals the number of votes needed for a tie), return a 1 (to be stored in 'tie_count'). Otherwise, the subset doesn't equal the 'tie', so the combination doesn't work and the function would return a 0.

